---
title: 'Phase 09: Attestation Protocol'
project: FIRM-LOCK
phase: 09
date: 2025-12-15
tags:
  - FIRM-LOCK
  - Protocol
  - Attestation
  - RATS
status: DRAFT
dependencies: "[[08_Firmware_Core.md]]"
next: "[[10_Secure_Update.md]]"
---

# Phase 09: Attestation Protocol

> **Objective:** To formally define the end-to-end remote attestation protocol, detailing the roles, responsibilities, data structures, and state machines for both the Prover (the FIRM-LOCK device) and the Verifier (the backend service). This ensures a secure, robust, and unambiguous communication process for verifying device integrity.
> **Duration:** 3 Days
> **Deliverables:**
> - A formal definition of the protocol's goals and participants.
> - Detailed specifications for all data structures (Challenge, Evidence, Policy).
> - State machine diagrams and logic for both the Prover and Verifier.
> - A security analysis of the protocol against identified threats.

---

## Table of Contents
1. [[#1. Protocol Overview & Goals]]
2. [[#2. Data Structure Definitions]]
3. [[#3. Prover (Device-Side) Logic]]
4. [[#4. Verifier (Backend-Side) Logic]]
5. [[#5. Detailed Protocol Sequence]]
6. [[#6. Security Analysis]]
7. [[#7. Network Transport Binding (LoRa)]]

---

## 1. Protocol Overview & Goals

Remote attestation is a conversation in which one party, the **Prover**, provides cryptographic evidence of its internal state to another party, the **Verifier**, which then assesses this evidence to make a judgment about the Prover's integrity.

### Core Goals
*   **Freshness:** The evidence provided by the Prover must be recent, proving its current state, not a past one. This is achieved using a **nonce**.
*   **Authenticity:** The Verifier must be able to cryptographically confirm that the evidence originated from a specific, authentic device. This is achieved using **asymmetric signatures** from a hardware-backed key.
*   **Integrity:** The evidence must contain an undeniable, tamper-evident summary of the Prover's software and configuration. This is achieved using **Platform Configuration Registers (PCRs)**.

### Roles
*   **Prover:** The FIRM-LOCK device. It is responsible for collecting evidence about its own state and cryptographically signing it.
*   **Verifier:** A backend service (running in the cloud or on-premises) that is responsible for challenging the Prover, receiving its evidence, and appraising it against a known-good policy.

---

## 2. Data Structure Definitions

These C-style structures formally define the data exchanged over the wire. They build upon the initial definitions in [[08_Firmware_Core.md|Phase 08]].

### 2.1 `AttestationChallenge`
Sent from the Verifier to the Prover.
```c
typedef struct __attribute__((packed)) {
    // A 32-byte random value generated by the Verifier for this specific session.
    // The Prover MUST include this exact value in its response.
    uint8_t nonce[32];

    // An ID for the Verifier, to prevent a malicious device from tricking
    // one Verifier with a challenge from another.
    uint8_t verifier_id[16];
} AttestationChallenge;
```

### 2.2 `AttestationEvidence`
Sent from the Prover to the Verifier. This is the core "proof" of integrity.
```c
typedef struct __attribute__((packed)) {
    // --- Signed Portion ---
    // The exact nonce received in the challenge.
    uint8_t nonce[32];

    // A snapshot of the device's PCRs, as generated by the measured boot process.
    uint8_t pcr_snapshot[4][32];

    // The device's public key certificate or unique ID, proving its identity.
    uint8_t device_identity[72]; // e.g., ATECC608A public key + signer info

    // The firmware version and security counter from the image header.
    uint32_t firmware_version;
    uint32_t security_counter;

    // A timestamp from the device's perspective (e.g., seconds since boot).
    uint32_t device_timestamp;
    // --- End of Signed Portion ---

    // An ECDSA-P256 signature over all the fields above this point.
    uint8_t signature[64];
} AttestationEvidence;
```

### 2.3 `AppraisalPolicy` (Verifier-Side)
This is the "golden" data the Verifier uses to judge the received `AttestationEvidence`.
```c
// Stored on the Verifier for each known firmware version.
typedef struct {
    uint32_t firmware_version;

    // The expected "golden" PCR values for this firmware version.
    uint8_t golden_pcrs[4][32];

    // The minimum acceptable security counter to prevent rollback attacks.
    uint32_t minimum_security_counter;

    // A list of public keys of authorized device manufacturers.
    uint8_t authorized_signer_certs[MAX_SIGNERS][72];
} AppraisalPolicy;
```

---

## 3. Prover (Device-Side) Logic

The Prover's logic is implemented as a state machine within the firmware.

### Prover State Machine
```
         ┌────────────────┐
         │      IDLE      │
         └───────┬────────┘
                 │ Receives Challenge Packet
                 ▼
         ┌────────────────┐
         │  GEN_EVIDENCE  │
         │(Builds & Signs)│
         └───────┬────────┘
                 │
     ┌───────────┴───────────┐
     │                       │
     ▼ Success               ▼ Failure (e.g., signing error)
┌────────────────┐      ┌────────────────┐
│ SEND_EVIDENCE  │      │   LOG_ERROR    │
└───────┬────────┘      └───────┬────────┘
        │ Sent                  │
        └───────────┬───────────┘
                    ▼
         ┌────────────────┐
         │      IDLE      │
         └────────────────┘
```

### Logic Flow
1.  **IDLE:** The device is in a low-power state, listening for incoming LoRa packets.
2.  **Challenge Received:** The Communication Task receives a packet, validates its CRC and preamble, and identifies it as an `AttestationChallenge`. It extracts the `nonce` and posts it to the Attestation Task's message queue.
3.  **GEN_EVIDENCE:** The high-priority Attestation Task wakes up. It calls the `build_attestation_evidence()` function from Phase 08. This involves:
    *   Getting a PCR quote.
    *   Reading the device identity from the Secure Element.
    *   Hashing the evidence structure.
    *   Calling the Secure Element driver to sign the hash.
4.  **Error Handling:** If any step in evidence generation fails (e.g., I2C communication error with the SE), the task logs a critical error and returns to IDLE. No response is sent.
5.  **SEND_EVIDENCE:** On success, the Attestation Task passes the completed `AttestationEvidence` structure to the Communication Task, which wraps it in a LoRa packet and transmits it.
6.  The device returns to the **IDLE** state.

---

## 4. Verifier (Backend-Side) Logic

The Verifier's logic is also a state machine, managing multiple attestation sessions concurrently.

### Verifier State Machine
```
         ┌────────────────┐
         │      IDLE      │
         └───────┬────────┘
                 │ Operator triggers attestation for Device X
                 ▼
         ┌────────────────┐
         │ SEND_CHALLENGE │
         │(Generate Nonce)│
         └───────┬────────┘
                 │ Challenge Sent, Start Timer
                 ▼
         ┌────────────────┐
         │ WAIT_EVIDENCE  │
         └───────┬────────┘
                 │
     ┌───────────┴───────────┐
     │ Evidence Received     │ Timeout
     ▼                       ▼
┌────────────────┐      ┌────────────────┐
│VERIFY_EVIDENCE │      │   LOG_TIMEOUT  │
└───────┬────────┘      └───────┬────────┘
        │                       │
┌───────┴───────┐     ┌─────────┴─────────┐
│               │     │                   │
▼ Pass          ▼ Fail│                   ▼
┌──────────┐ ┌──────────┐             ┌──────────┐
│  TRUSTED │ │UNTRUSTED │             │ UNKNOWN  │
└──────────┘ └──────────┘             └──────────┘
```

### Step-by-Step Verification Process
1.  **SEND_CHALLENGE:** The Verifier generates a cryptographically secure 32-byte `nonce`, stores it locally against the device's ID, and sends the `AttestationChallenge`. A timeout is started (e.g., 30 seconds).
2.  **WAIT_EVIDENCE:** The Verifier listens for a response. If the timeout expires, the device state is marked as `UNKNOWN`.
3.  **VERIFY_EVIDENCE:** When `AttestationEvidence` is received:
    a.  **Nonce Check:** The `nonce` in the evidence is compared to the one stored locally. If they don't match, the packet is an invalid response or a replay attack. **Verification fails.**
    b.  **Signature Verification:** The Verifier retrieves the device's public key (from `device_identity` or a database). It re-calculates the SHA-256 hash of the signed portion of the evidence and uses the public key to verify the `signature`. If the signature is invalid, the evidence is forged. **Verification fails.**
    c.  **Policy Appraisal:**
        i.  The Verifier loads the `AppraisalPolicy` corresponding to the `firmware_version` from the evidence.
        ii. It compares each PCR value from `pcr_snapshot` to the `golden_pcrs` in the policy. If any PCR does not match, the device's software/configuration has been altered. **Verification fails.**
        iii. It checks if `security_counter` is greater than or equal to the `minimum_security_counter` in the policy. If it's lower, it's a rollback attack. **Verification fails.**
4.  **Verdict:** If all checks pass, the device is marked as `TRUSTED`. If any check fails, it is marked as `UNTRUSTED`, and an alert is generated.

---

## 5. Detailed Protocol Sequence

This diagram shows the full end-to-end flow, including a failure path.

```
 Prover (Device)                     Verifier (Backend)
       │                                     │
       │ <---------------------------------- │ 1. Challenge(Nonce_A)
       │                                     │
       │ 2. Build Evidence(Nonce_A, PCRs,...)│
       │                                     │
       │ 3. Sign(Evidence) -> Signature_A    │
       │                                     │
       │ ----------------------------------> │ 4. Evidence(Nonce_A, PCRs, Sig_A)
       │                                     │
       │                                     │ 5. VERIFY:
       │                                     │    - Nonce == Nonce_A? (PASS)
       │                                     │    - Verify(Sig_A)? (PASS)
       │                                     │    - PCRs == Golden? (PASS)
       │                                     │
       │ <---------------------------------- │ 6. Verdict(TRUSTED)
       │                                     │
       │                                     │
       │ ================== FAILURE CASE ==================
       │                                     │
       │                                     │ (Attacker records previous message)
       │                                     │
       │ <---------------------------------- │ 7. Challenge(Nonce_B)
       │                                     │
       │                                     │ (Attacker replays old evidence)
       │ ----------------------------------> │ 8. Evidence(Nonce_A, PCRs, Sig_A)
       │                                     │
       │                                     │ 9. VERIFY:
       │                                     │    - Nonce == Nonce_B? (FAIL! Replay detected)
       │                                     │
       │                                     │ (No verdict sent, error logged)
       │                                     │
```

---

## 6. Security Analysis

*   **Replay Attack Mitigation (T04):** The use of a unique, single-use `nonce` for every challenge ensures that a recorded `AttestationEvidence` packet cannot be replayed later, as the nonce will not match the Verifier's expectation for the new session.
*   **Spoofing Mitigation:** The ECDSA signature, rooted in a hardware-protected private key, ensures that an attacker cannot forge evidence for a legitimate device. The Verifier can always prove the evidence came from the authentic hardware.
*   **Tampering Mitigation:** The PCR measurements provide a tamper-evident log of the boot process. Any modification to the firmware will result in a different PCR value, causing the appraisal to fail.
*   **Information Disclosure:** The protocol is designed to be minimal. The `AttestationEvidence` reveals the firmware version and its measurements, which is necessary for appraisal. It does not reveal unnecessary application data or device state.
*   **Clock Skew:** The `device_timestamp` field allows the Verifier to check for freshness even if there is significant network latency. The Verifier can have a policy that rejects evidence if the device's timestamp is too far in the past, even if the nonce is correct.

---

## 7. Network Transport Binding (LoRa)

The abstract `Challenge` and `Evidence` messages are wrapped in the `lora_packet_t` structure defined in Phase 08 for transmission.

*   **Challenge:** `msg_type = 0x01`, `payload` contains the `AttestationChallenge` structure.
*   **Evidence:** `msg_type = 0x02`, `payload` contains the `AttestationEvidence` structure.
*   **Reliability:** LoRa is an unreliable transport. The protocol as defined is a simple request-response. For higher reliability, a simple acknowledgement and retry mechanism can be added:
    *   The Verifier can re-transmit the `Challenge` up to 3 times if no `Evidence` is received within the timeout.
    *   The Prover can re-transmit the `Evidence` if it does not receive a `Verdict` packet within a certain window.

---

**Next Phase:** [[10_Secure_Update.md|Phase 10: Secure Update Mechanism]]
